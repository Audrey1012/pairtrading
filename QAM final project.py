# -*- coding: utf-8 -*-
"""Audre_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k0gEtHh0jM_uSG2lESP14UOuG3qXR6Te
"""

!pip install pycoingecko

from pycoingecko import CoinGeckoAPI
from datetime import timedelta
import time
import datetime as dt
import pandas as pd

cg = CoinGeckoAPI()

data = cg.get_coins_markets('usd')[:34]
ids = list()

for i in data:
  ids.append(i['id'])

print(ids)

def remove(target_list, remove_list):
  l = target_list

  for i in remove_list:
    idx = l.index(i)
    l.pop(idx)
  
  return l

ids = remove(ids, ['tether', 'usd-coin', 'binance-usd', 'wrapped-bitcoin', 'staked-ether', 'dai'])
print(ids)

end = dt.datetime(2022,5,26)
start = end - timedelta(days=85)

start_timestamp = time.mktime(start.timetuple())
end_timestamp = time.mktime(end.timetuple())

def create_csv(start_date, end_date, list_price, symbol):
  list_date = pd.date_range(start_date, end_date, freq='60min')[:2001]

  if len(list_date) != len(list_price):
    raise Exception(f'Check data length for symbol: {symbol}')
  df = pd.DataFrame({'date': list_date, 'close': list_price})
  df = df.set_index('date')
  df.to_csv(f'/content/STATICS/PRICE/{symbol}.csv')

len(list_price)

len(pd.date_range(start, end, freq='60min')[:-3])

for n in range(len(ids)):
  id = ids[n]

  if n%3 == 0:
    time.sleep(60)

  download = cg.get_coin_market_chart_range_by_id(id, vs_currency='usd', from_timestamp = start_timestamp,
                                                    to_timestamp = end_timestamp)['prices'][:2001]
  list_price = []

  for l in download:
    list_price.append(l[1])

  create_csv(start_date=start, end_date=end, list_price=list_price, symbol=id)

import pandas as pd
import numpy as np
import scipy
import seaborn as sns
import matplotlib.pyplot as plt
import os
from functools import reduce
from statsmodels.tsa.stattools import coint

file_names.remove('.ipynb_checkpoints')

sns.set(style='white')

# Retrieve intraday price data and combine them into a DataFrame.
# 1. Load downloaded prices from folder into a list of dataframes.
folder_path = r'/content/STATICS/PRICE'
file_names = os.listdir(folder_path)
tickers = [name.split('.')[0] for name in file_names]
df_list = [pd.read_csv(os.path.join(folder_path, name)) for name in file_names]

for i in range(len(df_list)):
    df_list[i].rename(columns={'close': tickers[i]}, inplace=True)

df_list

df  = reduce(lambda x, y: pd.merge(x, y, on='date'), df_list)
idx = round(len(df) * 0.7)
df  = df.iloc[:idx, :]

pearson_corr  = df[tickers].corr()
sns.clustermap(pearson_corr).fig.suptitle('Pearson Correlations')

sorted_mat = pearson_corr.unstack().sort_values(ascending=False)

print(sorted_mat[20:50])

pair1 = ['bitcoin', 'ftx-token']
pair2 = ['binancecoin', 'ethereum']
pair3 = ['uniswap', 'crypto-com-chain']

sns.set(style='darkgrid')
sns.jointplot(df[pair1[0]], df[pair1[1]],  kind='hex', color='orange')
sns.jointplot(df[pair2[0]],  df[pair2[1]], kind='hex', color='blue')
sns.jointplot(df[pair3[0]],  df[pair3[1]], kind='hex', color='red')

x = df[pair1[0]]
y = df[pair1[1]]
_, p_value, _ = coint(x, y)
print(f'The p_value of {pair1[0]}-{pair1[1]} pair cointegration is: {p_value}')

x = df[pair2[0]]
y = df[pair2[1]]
_, p_value, _ = coint(x, y)
print(f'The p_value of {pair2[0]}-{pair2[1]} pair cointegration is: {p_value}')

x = df[pair3[0]]
y = df[pair3[1]]
_, p_value, _ = coint(x, y)
print(f'The p_value of {pair3[0]}-{pair3[1]} pair cointegration is: {p_value}')

df2 = df[[pair1[0], pair1[1]]].copy()
spread = df2[pair1[0]] - df2[pair1[1]]
mean_spread = spread.mean()
df2['Dev'] = spread - mean_spread
rnd = np.random.choice(len(df), size=300)
sns.scatterplot(x=pair1[0], y=pair1[1], hue='Dev', linewidth=0.3, alpha=0.8,
                data=df2.iloc[rnd, :]).set_title(f'{pair1[0]}-{pair1[1]} Price Relationship')

df2 = df[[pair2[0], pair2[1]]].copy()
spread = df2[pair2[0]] - df2[pair2[1]]
mean_spread = spread.mean()
df2['Dev'] = spread - mean_spread
rnd = np.random.choice(len(df), size=300)
sns.scatterplot(x=pair2[0], y=pair2[1], hue='Dev', linewidth=0.3, alpha=0.8,
                data=df2.iloc[rnd, :]).set_title(f'{pair2[0]}-{pair2[1]} Price Relationship')

df2 = df[[pair3[0], pair3[1]]].copy()
spread = df2[pair3[0]] - df2[pair3[1]]
mean_spread = spread.mean()
df2['Dev'] = spread - mean_spread
rnd = np.random.choice(len(df), size=300)
sns.scatterplot(x=pair3[0], y=pair3[1], hue='Dev', linewidth=0.3, alpha=0.8,
                data=df2.iloc[rnd, :]).set_title(f'{pair3[0]}-{pair3[1]} Price Relationship')

def plot_spread(df, ticker1, ticker2, idx, th, stop):

    px1 = df[ticker1].iloc[idx] / df[ticker1].iloc[idx[0]]
    px2 = df[ticker2].iloc[idx] / df[ticker2].iloc[idx[0]]

    sns.set(style='white')

    # Set plotting figure
    fig, ax = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 1]})

    # Plot the 1st subplot
    sns.lineplot(data=[px1, px2], linewidth=1.2, ax=ax[0])
    ax[0].legend(loc='upper left')

    # Calculate the spread and other thresholds
    spread = df[ticker1].iloc[idx] - df[ticker2].iloc[idx]
    mean_spread = spread.mean()
    sell_th     = mean_spread + th
    buy_th      = mean_spread - th
    sell_stop   = mean_spread + stop
    buy_stop    = mean_spread - stop

    # Plot the 2nd subplot
    sns.lineplot(data=spread, color='#85929E', ax=ax[1], linewidth=1.2)
    ax[1].axhline(sell_th,   color='b', ls='--', linewidth=1, label='sell_th')
    ax[1].axhline(buy_th,    color='r', ls='--', linewidth=1, label='buy_th')
    ax[1].axhline(sell_stop, color='g', ls='--', linewidth=1, label='sell_stop')
    ax[1].axhline(buy_stop,  color='y', ls='--', linewidth=1, label='buy_stop')
    ax[1].fill_between(idx, sell_th, buy_th, facecolors='r', alpha=0.3)
    ax[1].legend(loc='upper left', labels=['Spread', 'sell_th', 'buy_th', 'sell_stop', 'buy_stop'], prop={'size':6.5})

idx = range(1000)
plot_spread(df, pair1[0], pair1[1], idx, 0.5, 1)

idx = range(1000)
plot_spread(df, pair2[0], pair2[1], idx, 0.5, 1)

idx = range(1000)
plot_spread(df, pair3[0], pair3[1], idx, 0.5, 1)

